# C# code generator & Object Relational Mapper
A C# code generator and an Object Relational Mapper (ORM), written in C#.

The goal of this project is twofold. On the one hand, we want to take annotated interface declarations and turn them into C# class declarations, also producing the corresponding SQL schema. On the other hand, we want to implement a simple ORM that's able to persist instances of the afore-mentioned generated classes to disk by storing them as database rows. Clearly, before doing that we create the appropriate tables according to the generated SQL schema. 
Finally, we also seek to do the opposite, namely retrieving records from a database and turn them into objects (i.e. instances of a class) in memory.

An example of an annotated interface declaration is included in the file [CodeGeneration/annotated_interfaces](CodeGeneration/annotated_interfaces), whose content is shown below:
```C#
@Table(name="book")
public interface Book {
    @Id(name="id")
    Integer id;
    
    @Column(name="title", length="80")
    String title;
    
    @Many2One(name="publisher", target="Publisher")
    Publisher publisher;
}

@Table(name="publisher")
public interface Publisher {
    @Id(name="id")
    Integer id;
    
    @Column(name="name", length="80")
    String name;
    
    @One2Many(name="books", target="Book", mappedBy="publisher")
    List<Book> books;
}
```

## Code generation
In order to turn annotated interface declarations into C# class declarations and SQL schema definitions, I have implemented a recursive descent parser that parses strings generated by the following grammar:
```
dec     ::= [sdec]+
sdec    ::= table mod ws interface ws str ws members
table   ::= @Table(name="str")
mod     ::= private | protected | public
members ::= {idmemb [memb]*}
idmemb  ::= @Id(name="str") str ws str;
memb    ::= colmemb | relmemb
colmemb ::= @Column(name="str" [, ws length="num"]?) str ws str;
relmemb ::= o2m | m2o
o2m     ::= @One2Many(name="str", ws target="str", ws mappedBy="str") str ws str;
m2o     ::= @Many2One(name="str", ws target="str") str ws str;
str     ::= any string
num     ::= any positive integer number
ws      ::= a single whitespace character
```
To learn more about the parser, check the [CodeGeneration/Parsing](CodeGeneration/Parsing) directory.

The [CodeGeneration/SyntacticElements](CodeGeneration/SyntacticElements) directory contains classes that encapsulate annotations. Annotations can be of two types: **Table** annotations (i.e. those that specify which table an interface will be mapped to) and **Member** annotations (used to map members of an interface to columns of a table as well as to define primary/foreign key constraints).

Possibly the most important piece of the code generation part of this project is the `CodeGenerator` class (located in [CodeGeneration/CodeGenerators/CodeGenerator.cs](CodeGeneration/CodeGenerators/CodeGenerator.cs)). Its job is to take table and member annotations as returned by the parser and use them to generate a C# class declaration and a SQL schema. If you feed the [CodeGeneration/annotated_interfaces](CodeGeneration/annotated_interfaces) file to the code generator, here's the corresponding C# code you would get:
```C#
public class Book {
    public int id;
    public string title;
    public Publisher publisher;
}

public class Publisher {
    public int id;
    public string name;
    public List<Book> books;
}
```
and here's the generated SQL schema:
```SQL
CREATE TABLE book (
    id INT NOT NULL PRIMARY KEY,
    title VARCHAR(80),
    publisher INT,
    FOREIGN KEY (publisher) REFERENCES publisher(id)
);

CREATE TABLE publisher (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(80)
);
```

## Object Relational Mapper
The key class for this part of the project is `EntityManager` (located in [ObjectRelationalMapper/EntityManagement/EntityManager.cs](ObjectRelationalMapper/EntityManagement/EntityManager.cs)). `EntityManager` is used to turn class instances into database rows and vice-versa, and it does so by implementing methods for:
 - persisting an object (of type `T`) to the database
 - removing the record that corresponds to a given object (of type `T`) from the database 
 - retrieving a record from the database and using it to instantiate an object (of type `T`)
 
## Usage
If you want to test the functionalities of this system, run [CodeGeneration/Program.cs](CodeGeneration/Program.cs) to generate C# class declarations and a SQL schema definition for the interfaces in [CodeGeneration/annotated_interfaces](CodeGeneration/annotated_interfaces) (in this case, they are `Book` and `Publisher`), then run [ObjectRelationalMapper/Program.cs](ObjectRelationalMapper/Program.cs) to create some instances of the generated classes and store them as records in a SQLite database.
