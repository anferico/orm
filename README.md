# Object Relational Mapper
A simple code generator and Object Relational Mapper (ORM) written in C#.

The goal of this project is twofold. On the one hand, we want to take annotated interface declarations and use them to create valid C# code and a corresponding SQL schema. On the other hand, we want to implement a simple ORM that's able to persist objects in main memory to disk by storing them as database rows. We also seek to do the opposite, namely retrieving records from a database and turn them into objects (i.e. instances of a class).

An example of an annotated interface declaration is included in the file [annotated_interfaces](annotated_interfaces), whose content is shown below:
```C#
@Table(name="book")
public interface Book {
    @Id(name="id")
    Integer id;
    
    @Column(name="title", length="80")
    String title;
    
    @Many2One(name="publisher", target="Publisher")
    Publisher publisher;
}

@Table(name="publisher")
public interface Publisher {
    @Id(name="id")
    Integer id;
    
    @Column(name="name", length="80")
    String name;
    
    @One2Many(name="books", target="Book", mappedBy="publisher")
    List<Book> books;
}
```

In order to turn annotated interface declarations into actual code, I have implemented a recursive descent parser that parses strings generated by the following grammar:
```
dec     ::= [sdec]+
sdec    ::= table mod ws interface ws str ws members
table   ::= @Table(name="str")
mod     ::= private | protected | public
members ::= {idmemb [memb]*}
idmemb  ::= @Id(name="str") str ws str;
memb    ::= colmemb | relmemb
colmemb ::= @Column(name="str" [, ws length="num"]?) str ws str;
relmemb ::= o2m | m2o
o2m     ::= @One2Many(name="str", ws target="str", ws mappedBy="str") str ws str;
m2o     ::= @Many2One(name="str", ws target="str") str ws str;
str     ::= any string
num     ::= any positive integer number
ws      ::= a single whitespace character
```
To learn more about the parser, check the [Parsing](Parsing) directory.

The [SyntacticElements](SyntacticElements) directory contains classes that encapsulate annotations. Annotations can be of two types: **Table** annotations (i.e. those that specify which table an interface will be mapped to) and **Member** annotations (used to map members of an interface to columns of a table as well as to define primary/foreign key contraints).

Possibly the most important part of this project is the `CodeGenerator` class (located in [CodeGenerators/CodeGenerator.cs](CodeGenerators/CodeGenerator.cs)). Its job is to take table and member annotations as returned by the parser and use them to generate C# code and a SQL schema. If you feed the [annotated_interfaces](annotated_interfaces) file to the code generator, here's the corresponding C# code you would get:
```C#
public class Book {
    public int id;
    public string title;
    public Publisher publisher;
}

public class Publisher {
    public int id;
    public string name;
    public List<Book> books;
}
```
and here's the generated SQL schema:
```SQL
CREATE TABLE book (
    id INT NOT NULL PRIMARY KEY,
    title VARCHAR(80),
    publisher INT,
    FOREIGN KEY (publisher) REFERENCES publisher(id)
);

CREATE TABLE publisher (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(80)
);
```
